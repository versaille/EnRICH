/*  <EnRICH qualitatively integrate heterogeneous data sets while filtering each of them based on its attributes.>
    Copyright (C) <2012>  <Xia Zhang>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>
 */
import java.awt.Color;
import java.util.HashMap;
import java.util.Vector;

import processing.core.*;

public class NetworkSketch extends PApplet{
	 //variables for borders of three sketches, and shared by three sketches
	  private int w, h;
	  private float border;
	  private PFont font;
	  private int fontsize1, fontsize2;

	  //variables for sketch 1: node STAT plot
	
	  private float plotX1, plotY1;
	  private float plotX2, plotY2;
	  private float yNXlabel, xNYlabel; //y location of X axis label & x location of Y axis label
	  private float yNXscale, xNYscale; //y location of X axis scale text & x location of Y axis scale text
	  private int NX[], NY[]; //statistical data which decide positions of data points within the plot
	  private int axisNX[], axisNY[]; //scale data labeled on x and y axis, generated by scaleGenerator
	  private int maxNX, maxNY; //maximal value of NX[], NY[];
	  private int intervalNX, intervalNY; //the number of intervals on axis
	  private float[][] NLocation; // data point position
	  private static final int NdataColor=0xFFFF0000; //red
	  
	  //variables for sketche 2: edge STAT plot
	  
	  private float plotX3, plotY3;
	  private float plotX4, plotY4;
	  private float yEXlabel, xEYlabel; //y location of X axis label & x location of Y axis label
	  private float yEXscale, xEYscale;
	  private int EX[], EY[];
	  private int axisEX[], axisEY[];
	  private int maxEX, maxEY;
	  private int intervalEX, intervalEY;
	  private float [][] ELocation; //data point location
	  static final int EdataColor=0xFF0000FF; //blue
	  
	  //variables for sketch 3: network
	  private PNode[] nodes=new PNode[100];
	  private PEdge[] edges=new PEdge[500];
	  private HashMap nodeTable=new HashMap();
	  private int nodeCount=0; //the total number of nodes that are drawn
	  private int edgeCount=0; //the total number of edges that are drawn
	  private int nodeFilter; //parameter passed from mouse
	  private int edgeFilter;
	  private PNode selection; //the node on which mouse is put
	  private PEdge selection2; //the edge on which mouse is put
	  private int edgeLength; //default length of edge
	  private static final int nodeColor=0xFFFFA500; //yellow
	  private static final int selectColor=0xFF800080; //purple
	  private static final int fixedColor=0xFFFFCCCC; //pink
	  private static final int nodeTextColor=0xFF000000; //black
	  private static final int nodeStrokeColor=0xFFFF3030; //red
	  private static final int edgeColor=0xFF6960EC;//#5757FF;//#01FCEF; 
	  private static final int diredgeColor=0xFFFFCCCC;
	  private static final int arrowStrokeColor=0xFFFF3030;//red
	  private static final int sourcesRecColor=0xFFCCCCFF;//#CCFFFF; //green
	  private static final int sourcesColor=0xFF000000; //black
	  private static final int dirsourcesRecColor=0xFFCCFFFF;//#CCCCFF; //purple
	  
	  //values being passed through constructor
	  private int[][] nodeStat;
	  private int[][] edgeStat;
	  private Node[] nodeArr;
	  private Edge[] edgeArr;
	  
	  
	  
	public NetworkSketch(int[][] nodeStat, int[][] edgeStat,
			Edge[] edgeArr, int w, int h) {
		// TODO Auto-generated constructor stub
		this.nodeStat=nodeStat;
		this.edgeStat=edgeStat;
		this.edgeArr=edgeArr;
		this.w=w;
		this.h=h;
	}
	
	public void setup(){
		int titleBarHt=getBounds().y;
		System.out.print("barHeight:"+titleBarHt);
	      size(w, h-titleBarHt);
	      border=w-h*0.5f;
	      fontsize1=w/100;
	      fontsize2=w/80;
	      edgeLength=w/5;
	      //set node stat plot position
	      plotX1=w-h*0.5f*0.7f;
	      plotX2=w-h*0.5f*0.05f;
	      plotY1=h*0.5f*0.05f;
	      plotY2=0.5f*h*0.7f;
	      yNXscale=h*0.5f*0.81f;
	      xNYscale=w-h*0.5f*0.81f;
	      yNXlabel=h*0.5f*0.92f;
	      xNYlabel=w-h*0.5f*0.92f;
	      
	      //set edge stat plot position
	      plotX3=w-h*0.5f*0.7f;
	      plotX4=w-h*0.5f*0.05f;
	      plotY3=0.5f*h+h*0.5f*0.05f;
	      plotY4=0.5f*h+h*0.5f*0.7f;
	      yEXscale=0.5f*h+h*0.5f*0.81f;
	      xEYscale=w-h*0.5f*0.81f;
	      yEXlabel=0.5f*h+h*0.5f*0.92f;
	      xEYlabel=w-h*0.5f*0.92f;
	      
	      //load data
	      loadNodeStatData();
	      loadEdgeStatData();
	      loadNetworkData();
	      
	    }
	
	    public void draw(){
	       background(255);
		   smooth();
		      
		   drawBorders();
		   drawNodePlot();
		   drawEdgePlot(); 
		   drawNetwork();
	      
	    }
	    
	    public void drawBorders(){
	      stroke(0);
	      strokeWeight(1);
	      line(border, 0, border, h);
	      line(border, h*0.5f, w, h*0.5f);
	    }
	    
	    public void saveImage(String filename){
	      save(filename);
	    }
	    
	    /* CONTAINS:
	    void loadNodeStatData()
	    void loadEdgeStatData()
	           which invoke:
	                   int getFirstCeil(int n);
	                   float getInteCeil (float n); 
	    -------------------------------------------------
	    void loadNetworkData() which invokes 
	            void addEdge(String fromLabel...) which invokes
	                     Node findNode(String) which invokes
	                             Node addNode(String)
	  */
	    void loadNodeStatData(){
	    	NX=new int [nodeStat.length];
	    	NY=new int [nodeStat.length];
	    	for (int i=0; i<nodeStat.length; i++){
	    		NX[i]=nodeStat[i][0]; //column 0 of nodeStat
	    		NY[i]=nodeStat[i][1]; //column 1 of nodeStat
	    	}
	        maxNX=max(NX);
	        maxNY=max(NY);
	        if (maxNX<=10000){
	            int increNX=ceil(getFirstCeil((float)maxNX)/10);
	            //intervalNX=ceil(getSecondCeil((float)maxNX)/increNX);  
	            axisNX=scaleGenerator(11, increNX);
	            //axisNX=scaleGenerator(intervalNX+1, increNX);
	        } else {
	              int increNX=ceil (getInteCeil((float)maxNX)/10);
	              intervalNX=ceil(log(maxNX)/log(10)); //convert e-base to 10-base;
	              axisNX=scaleGenerator(intervalNX+1, increNX);
	          }
	    
	        if (maxNY<=10000){
	            int increNY=ceil(getFirstCeil((float)maxNY)/10);
	            axisNY=scaleGenerator(11, increNY);
	        } else{
	              int increNY=ceil (getInteCeil((float)maxNY)/10);
	              intervalNY=ceil(log(maxNY)/log(10));
	              axisNY=scaleGenerator(intervalNY+1, increNY);
	          }
	       }//loadNodeData() end
	       
	      void loadEdgeStatData(){
	    	EX=new int[edgeStat.length];
	    	EY=new int[edgeStat.length];
	    	for (int i=0; i<edgeStat.length; i++)
	    	{
	    		EX[i]=edgeStat[i][0];
	    		EY[i]=edgeStat[i][1];
	    	}
	        maxEX=max(EX);
	        maxEY=max(EY);
	        if (maxEX<=10000){
	            int increEX=ceil(getFirstCeil((float)maxEX)/10);
	            axisEX=scaleGenerator(11, increEX);
	        } else {
	              int increEX=ceil (getInteCeil((float)maxEX)/10);
	              intervalEX=ceil(log(maxEX)/log(10));//convert e-base to 10-base
	              axisEX=scaleGenerator(intervalEX+1, increEX);
	          }
	     
	        if (maxEY<=10000){
	            int increEY=ceil(getFirstCeil((float)maxEY)/10);
	            axisEY=scaleGenerator(11, increEY);
	        } else{
	              int increEY=ceil (getInteCeil((float)maxEY)/10);
	              intervalEY=ceil(log(maxEY)/log(10));
	              axisEY=scaleGenerator(intervalEY+1, increEY);
	          }
	       }//loadEdgeData() end
	       
	       
	      // eg. return 4000 for 3245
	      float getFirstCeil(float n){
	        float m=1;
	        while(n/m>=10){
	        m=m*10;
	        }
	        return ceil(n/m)*m;
	      }

	      
	      //eg. get log(10000) for 1289 or 9821, any number <=10000*/
	      float getInteCeil(float n) {
	        float m=1;
	        while(n/m>1){
	        m=m*10;
	        }
	        float x=ceil(n/m)*m;
	        return log(x)/log(10); //convert e-base to 10-base
	      }
	      /*scaleGenerator returns an int array of which the length and interval
	      are specified by parameter arraylength and increment*/
	      int[] scaleGenerator(int arraylength, int increment){
	        int[] myArray= new int[arraylength];
	        myArray[0]=0;
	        for (int i=1; i<arraylength; i++){
	          myArray[i] =myArray[i-1]+increment;
	        }
	        return myArray;
	      }
	    // ----------------------------------------------------------------
	        
	       void loadNetworkData()
	       {
	         for(int i=0; i<edgeArr.length; i++)
	         {
	           addEdge(edgeArr[i]);
	         }
	       }
	       
	       void addEdge(Edge e)
	       {
	    	 PNode from=findNode(e.getFrom()) ;
	    	 PNode to=findNode(e.getTo());
	    	 int count=e.getTotalCount();
	    	 int dirCount=e.getDirCount();
	    	 Vector<String> source=e.getSource();
	    	 
	         PEdge edge=new PEdge(from, to, count, source,  dirCount );
	         if (edgeCount==edges.length)
	         {
	           edges=(PEdge[])expand(edges);
	         }
	         edges[edgeCount++]=edge;
	       }
	       
	        PNode findNode(Node n) {
			// TODO Auto-generated method stub
	        	String label=n.getLabel().toLowerCase();
	            PNode node=(PNode) nodeTable.get(label);
	            if (node==null){
	                return addNode(n);
	            }
	            return node;
	        }

	        PNode addNode(Node node)
	        {
	        	PNode n=new PNode(node);
	        	if (nodeCount==nodes.length){
	        		nodes=(PNode[])expand(nodes);
	        	}
	        	nodeTable.put(node.getLabel(),n);
	        	nodes[nodeCount++]=n;
	        	return n;
	        }
	       
	       /* Edge Class
	       @Methods: void relax(); void draw()
	       */
	       class PEdge{
	    	   PNode from;  //one of the two node
	    	   PNode to;    
	    	   int count;    //rank
	    	   int dirCount;
	    	   Vector<String> source;   //sources: network titles it belongs to 
	    	   float len;    //edge length
	    	   boolean fixed;  //mouse 
	    	   //boolean dir;    //if this edge is direct, dir=true
	    	   boolean disable;  //if this edge is not displayed, disable=true
	    	   String sourceLabel;
	       
	    	   PEdge(PNode from, PNode to, int count, Vector<String> source,  int dirCount)  {
	    		   this.from=from;
	    		   this.to=to;
	    		   this.count=count;
	    		   this.source=source;
	    		   this.dirCount=dirCount;
	    		   this.len=edgeLength;// re-adjust it using screen width;
	    		   this.disable=false;
	    		   this.fixed=false;
	    		   this.sourceLabel=vectorToString(this.source);
	    	   }
	    	   private String vectorToString(Vector<String> source2) {
				// TODO Auto-generated method stub
	    		   StringBuilder builder=new StringBuilder();
	    		   for (int i=0; i<source.size(); i++)
	    		   {
	    			   builder.append(source.get(i)).append(';');
	    		   }
	    		   return builder.toString();
	    	   }
	    	   void switchLabel(){
	    		   if (this.fixed==false)this.fixed=true;
	    		   else this.fixed=false;
	    	   }

	    	   void disable(){
	    		   this.disable=true;
	    	   }
	    	   void enable(){
	    		   this.disable=false;
	    	   }
	    	   void relax(){  //this functions  moves d closer to len
	    		   float vx=to.x-from.x;
	    		   float vy=to.y-from.y;
	    		   float d=mag(vx, vy);
	    		   if (d>0){
	    			   float f=(len-d)/(d*3);
	    			   float dx= f*vx;
	    			   float dy=f*vy;
	    			   to.dx += dx; 
	    			   to.dy += dy;
	    			   from.dx -= dx;
	    			   from.dy -= dy;
	    		   }
	    	   }//relax()end
	         
	    	   void draw(){
	                 	if (dirCount==0){ // if not direct edge, draw a line
	                 		stroke(edgeColor);
	                 		strokeWeight(count*0.7f);
	                 		line(from.x, from.y, to.x, to.y);
	                 		//if mouse on this edge and right mouseButton is pressed, display sources
	                 		if (selection2==this && fixed==true ){ 
	                 			stroke(0);
	                 			strokeWeight(1);
	                 			rectMode(CORNER);
	                 			float sw=textWidth(this.sourceLabel)+8;
	                 			float sh=textAscent()+textDescent();
	                 			fill(sourcesRecColor);
	                 			rect((from.x+to.x)/2,(from.y+to.y)/2, sw, sh);
	                 			fill(sourcesColor);
	                 			textAlign(CENTER, CENTER);
	                 			text(this.sourceLabel,(from.x+to.x)/2+sw/2,(from.y+to.y)/2+sh/2);
	                 		}
	                 	} else if (dirCount>0){ //if direct edge, draw a line and a triangle 
	           
	                 			if(count-dirCount>0){
	                 				stroke(edgeColor);
	                 				fill(edgeColor,120);
	                 				strokeWeight((count-dirCount)*1.2f);
	                 			}else{
	                 				stroke(diredgeColor);
	                 				fill(diredgeColor,120);
	                 				strokeWeight(dirCount*1.2f);
	                 			}
	                      
	                 			line(from.x, from.y, to.x, to.y);
	                 			float m=from.x+(to.x-from.x)*0.8f;
	                 			float n=from.y+(to.y-from.y)*0.8f;
	                 			float md=from.x+(m-from.x)*0.9f;
	                 			float nd=from.y+(n-from.y)*0.9f;
	                 			//for triangle solution
	                       //float bd=mag(m-md,n-nd)*0.5; //half length of triangle bottom line
	                 			float bd=5*dirCount;
	                 			float k=(from.x-to.x)/(to.y-from.y); //k=slope of triangle bottom line
	                 			float b=nd-k*md; //intercept;
	                 			float a=1+sq(k);  //quadratic equation parameter for sq(x)
	                 			float bb=2*(k*b-k*nd-md); //quadratic equation parameter for x
	                 			float c=sq(md)+sq(nd)+sq(b)-2*b*nd-sq(bd); 
	                 			float x1=(-bb+sqrt(sq(bb)-4*a*c))/(2*a);
	                 			float x2=(-bb-sqrt(sq(bb)-4*a*c))/(2*a);
	                 			float y1=k*x1+b;
	                 			float y2=k*x2+b;
	                 			stroke(arrowStrokeColor,160);
	                 			fill(diredgeColor,120);
	                 			strokeWeight(dirCount*1.2f);
	                 			triangle(m,n, x1,y1,x2,y2); 
	               
	                 			if (selection2==this && fixed==true ){
	                 				stroke(0);
	                 				strokeWeight(1);
	                 				rectMode(CORNER);
	                 				float sw=textWidth(this.sourceLabel)+8;
	                 				float sh=textAscent()+textDescent();
	                 				fill(dirsourcesRecColor);
	                 				rect((from.x+to.x)/2-sw,(from.y+to.y)/2-sh, sw, sh);
	                 				fill(sourcesColor);
	                 				textAlign(CENTER, CENTER);
	                 				text(this.sourceLabel,(from.x+to.x)/2-sw/2,(from.y+to.y)/2-sh/2);
	                 			}
	                 		}
	    	   		}//Edge.draw() end
	       }// Class Edge end
	     
	       /*Node Class
	       @Methods: void relax(); void update(); void draw()
	       void increment(int x); void decrease(int y); 
	       */
	       class PNode {
	           float x, y; //Location 
	           float dx, dy; //for relax
	           Boolean fixed; //show or hide label
	           String label; //node name
	           int oriCount; //original count of node
	           int count; //dynamic count of node as edge is removed.
	           Boolean disable;
	           Vector<String> source;
	            
	           PNode (Node n){
	             this.label=n.getLabel();
	             this.oriCount=n.getCount();
	             this.source=n.getSource();
	             this.fixed=false;
	             this.disable=false;
	             this.count=n.getCount();
	             x=random(border-30);
	             y=random(h-30);
	           }
	           void switchLabel(){
	             if(fixed==true) fixed=false;
	             else fixed=true;
	           }
	         
	           //calculate the dynamic count of this node when its edge is removed
	          //in order to decide whether this node also should be removed together 
	           void  decrease(int y){ 
	             count -= y;    
	           }
	           void resetCount(){
	             count=oriCount;
	           }
	           
	           void disable(){
	             this.disable=true;
	           }
	            void enable(){
	             this.disable=false;
	           }
	           void relax(){
	             float ddx=0;
	             float ddy=0;
	             for (int j=0; j<nodeCount; j++){
	               PNode n=nodes[j];
	              if (n!=this && n.disable==false){ //compare to other node's location
	                 float vx=x-n.x;
	                 float vy=y-n.y;
	                 float lensq=vx*vx+vy*vy;
	                 if (lensq<=20){ //if overlap
	                   ddx += random(1);
	                   ddy += random(1);
	                 } else if (lensq<100*100){ // if too close
	                    ddx += vx/lensq;
	                    ddy +=vy/lensq;
	                  }
	               }//if end
	             }//for end
	             float dlen=mag(ddx, ddy)/2;
	             if (dlen>0){
	               dx += ddx/dlen;
	               dy += ddy/dlen;
	             }  
	            }//Node.relax() end
	            
	            void update (){
	            	
	                x +=constrain(dx,-5, 5);
	                y +=constrain(dy, -5, 5);
	                x=constrain (x, 10, border-30);
	                y=constrain(y,10, height-10);
	            
	              dx /= 2;
	              dy /= 2;
	            }//Node.updata() end
	            
	            void draw (){
	            	if(fixed==true){  //if mouse on this node  
	                      fill(fixedColor,120);   //pink
	                      stroke(nodeStrokeColor,180);
	                      strokeWeight(1);
	                      float w=textWidth(label)+8;
	                      float h=textAscent()+textDescent()+ 8;
	                      ellipse(x,y, w, h); //draw a text-size ellipse
	                      fill(nodeTextColor,240);
	                      textAlign(CENTER, CENTER);
	                      text(label,x,y);     //display node label
	                  }else { //if mouse not on this node
	                    fill(nodeColor,50);  //yellow
	                    stroke(0);
	                    strokeWeight(1);
	                    ellipse(x, y, 5+20*this.oriCount/maxNY, 5+20*this.oriCount/maxNY); // a small ellipse denotes the node
	                    
	                  } 
	            }//Node.draw() end
	         }//Node Class end
	       
	       //***********************************Node Stat Plot************************************ 
	       void drawNodePlot(){
	         drawNDataPoint();
	         drawNCoordinate();
	         
	         //draw axis and its label
	         drawAxisNX();
	         if(maxNX<=10000){
	           drawNXLabel();
	         }else{
	           drawLogNXLabel();
	         }
	         
	         drawAxisNY();
	         if(maxNY<=10000){
	           drawNYLabel();
	         }else{
	           drawLogNYLabel();
	         }
	       }
	       //-------------------------node data point and coordinate------------------------------
	       
	       void drawNDataPoint(){
	         fill(NdataColor); //data point color
	         stroke(0);
	         strokeWeight(0.5f);
	         float nx, ny;
	         NLocation=new float[NX.length][2];
	         for (int i=0; i<NX.length; i++){
	           //map data point to pixel
	           if (maxNX<=10000){
	             nx=map(NX[i], 0, axisNX[axisNX.length-1],plotX1, plotX2);
	           }else{
	             nx=map(log(NX[i])/log(10), 0, axisNX[axisNX.length-1], plotX1, plotX2);
	           }
	           if(maxNY<=10000){
	             ny=map(NY[i], 0, axisNY[axisNY.length-1], plotY2, plotY1);
	           }else{
	             ny=map(log(NY[i])/log(10), 0, axisNY[axisNY.length-1], plotY2, plotY1);
	           }
	           //draw each point
	           NLocation[i][0]=nx;
	           NLocation[i][1]=ny;
	           rectMode(CENTER);
	           rect(nx, ny, 6, 6);
	         }//for end
	         noFill();
	       }//drawDataPoint() end
	       
	       void drawNCoordinate(){
	         stroke(0);
	         rectMode(CORNERS);
	        // rect(plotX1, plotY1, plotX2, plotY2);
	        line(plotX1, plotY1,plotX1,plotY2);
	        line(plotX1, plotY2,plotX2,plotY2);
	       }
	       
	       //--------------------------node X axis and its label----------------------------
	       void drawAxisNX(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize1);
	         textFont(font);
	         textAlign(CENTER);
	         for (int i=0; i<axisNX.length;i++){
	           float x=map(axisNX[i], 0, axisNX[axisNX.length-1], plotX1, plotX2); 
	           line(x, plotY2, x, plotY2+2);
	           text(axisNX[i],x, yNXscale); //text(data, x, y)
	         }
	       }
	       
	       void drawNXLabel(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize2);
	         textFont(font);
	         textAlign(CENTER);
	         text("Node Degree", (plotX1+plotX2)/2, yNXlabel);
	       }
	       
	       void drawLogNXLabel(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize2);
	         textFont(font);
	         textAlign(CENTER);
	         text("Log(Node Degree)", (plotX1+plotX2)/2, yNXlabel); //you can use getColumn Label
	       }
	       //--------------------node Y axis and its label-----------------------
	       void drawAxisNY(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize1);
	         textFont(font);
	         textAlign(CENTER);
	         for (int i=0; i<axisNY.length;i++){
	           float y=map(axisNY[i], 0, axisNY[axisNY.length-1], plotY2, plotY1);
	           line(plotX1, y, plotX1-2, y);
	           text(axisNY[i],xNYscale, y);
	         }
	       }
	       
	       void drawNYLabel(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize2);
	         textFont(font);
	         translate(xNYlabel, (plotY1+plotY2)/2);
	         rotate(TWO_PI-HALF_PI);
	         textAlign(CENTER);
	         text("The number of nodes", 0,0);
	         rotate(HALF_PI);
	          translate(-(xNYlabel), -(plotY1+plotY2)/2);
	       }
	       
	       void drawLogNYLabel(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize2);
	         textFont(font);
	         translate(xNYlabel, (plotY1+plotY2)/2);
	         rotate(TWO_PI-HALF_PI);
	         textAlign(CENTER);
	         text("Log(The number of nodes)", 0,0);
	          rotate(HALF_PI);
	          translate(-(xNYlabel), -(plotY1+plotY2)/2);
	       }
	       //*****************************Edge Stat Plot***************************************
	       
	       void drawEdgePlot(){
	        
	         drawEDataPoint();
	         drawECoordinate();
	         
	         //draw axis and its label
	         drawAxisEX();
	         if(maxEX<=10000){
	           drawEXLabel();
	         }else{
	           drawLogEXLabel();
	         }
	         
	         drawAxisEY();
	         if(maxEY<=10000){
	           drawEYLabel();
	         }else{
	           drawLogEYLabel();
	         }
	       }
	       //-------------------------edge data point and coordinate------------------------------
	       
	       void drawEDataPoint(){
	         fill(EdataColor); //data point color
	         stroke(0);
	         strokeWeight(0.5f);
	         float ex, ey;
	         ELocation=new float [EX.length][2];
	         for (int i=0; i<EX.length; i++){
	           //map data point to pixel
	           if (maxEX<=10000){
	             ex=map(EX[i], 0, axisEX[axisEX.length-1],plotX3, plotX4);
	           }else{
	             ex=map(log(EX[i])/log(10), 0, axisEX[axisEX.length-1], plotX3, plotX4);
	           }
	           if(maxEY<=10000){
	             ey=map(EY[i], 0, axisEY[axisEY.length-1], plotY4, plotY3);
	           }else{
	             ey=map(log(EY[i])/log(10), 0, axisEY[axisEY.length-1], plotY4, plotY3);
	           }
	           //draw each point
	           ELocation[i][0]=ex;
	           ELocation[i][1]=ey;
	           rectMode(CENTER);
	           rect(ex, ey, 6, 6);
	       
	         }//for end
	         noFill();
	       }//drawEDataPoint() end
	       
	       void drawECoordinate(){
	         stroke(0);
	         strokeWeight(0.5f);
	         rectMode(CORNERS);
	        // rect(plotX3, plotY3, plotX4, plotY4);
	        line(plotX3, plotY3,plotX3,plotY4);
	        line(plotX3, plotY4,plotX4,plotY4);
	       }
	       
	       //--------------------------edge X axis and its label----------------------------
	       void drawAxisEX(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize1);
	         textFont(font);
	         textAlign(CENTER);
	         for (int i=0; i<axisEX.length;i++){
	           float x=map(axisEX[i], 0, axisEX[axisEX.length-1], plotX3, plotX4);
	           line(x, plotY4, x, plotY4+4);
	           text(axisEX[i],x, yEXscale);
	         }
	       }
	       
	       void drawEXLabel(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize2);
	         textFont(font);
	         textAlign(CENTER);
	         text("Edge Reoccurance", (plotX3+plotX4)/2, yEXlabel);
	       }
	       
	       void drawLogEXLabel(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize2);
	         textFont(font);
	         textAlign(CENTER);
	         text("Log(Edge Reoccurance)", (plotX3+plotX4)/2, yEXlabel);
	       }
	       //--------------------edge Y axis and its label-----------------------
	       void drawAxisEY(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize1);
	         textFont(font);
	         textAlign(CENTER);
	         for (int i=0; i<axisEY.length;i++){
	           float y=map(axisEY[i], 0, axisEY[axisEY.length-1], plotY4, plotY3);
	           line(plotX3, y, plotX3-4, y);
	           text(axisEY[i],xEYscale, y);
	         }
	       }
	       
	       void drawEYLabel(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize2);
	         textFont(font);
	         translate(xEYlabel, (plotY3+plotY4)/2);
	         rotate(TWO_PI-HALF_PI);
	         textAlign(CENTER);
	         text("The number of edges", 0,0);
	         
	         rotate(HALF_PI);
	         translate(-(xEYlabel), -(plotY3+plotY4)/2);
	       }
	       
	       void drawLogEYLabel(){
	         fill(0);
	         stroke(0);
	         strokeWeight(0.5f);
	         font=createFont("SanSerif",fontsize2);
	         textFont(font);
	         translate(xEYlabel, (plotY3+plotY4)/2);
	         rotate(TWO_PI-HALF_PI);
	         textAlign(CENTER);
	         text("Log(The number of edges)", 0,0);
	         rotate(HALF_PI);
	         translate(-(xEYlabel), -(plotY3+plotY4)/2);
	       }
	       //******************************Network Sketch***********************************
	       void drawNetwork(){
	         for (int i=0; i<edgeCount; i++){
	           edges[i].relax();
	         }
	         for (int i=0; i<nodeCount; i++){
	           nodes[i].relax();
	         }
	         for (int i=0; i<nodeCount; i++){
	           nodes[i].update();
	         }
	         for (int i=0; i<edgeCount; i++){
	           if (edges[i].disable==false) edges[i].draw();
	         }
	         for (int i=0; i<nodeCount; i++){
	           if (nodes[i].disable==false && nodes[i].count>0) nodes[i].draw();
	         }
	       }//drawNetwork() end
	       
	     //******************************Mouse Interaction***********************************
	       
	       public void mouseClicked(){
	    	      
	    	      if (mouseX>border && mouseY<0.5*h)
	    	      {
	    	          for (int i=0; i<NX.length;i++)
	    	          {
	    	            float d=dist(mouseX, mouseY, NLocation[i][0],NLocation[i][1]);
	    	            if (d<4.5)
	    	            {
	    	              nodeFilter=NX[i];
	    	              edgeFilter=0;
	    	              resetNode(); //node.count is related to edge display condition
	    	              resetEdge();
	    	              updateNode();
	    	              updateEdge();
	    	              redraw();
	    	            }
	    	          }//for end
	    	        } else if (mouseX>border && mouseY>0.5*h){
	    	          for (int i=0; i<EX.length;i++){
	    	            float d=dist(mouseX, mouseY, ELocation[i][0],ELocation[i][1]);
	    	            if (d<6){
	    	              edgeFilter=EX[i];
	    	              nodeFilter=0;
	    	              resetNode();
	    	              resetEdge();
	    	              updateEdge();
	    	              updateNode();
	    	              redraw();
	    	            }
	    	          }//for end
	    	        } else if (mouseX<border){//while mouseX<border
	    	            nodeSelected();
	    	            if (selection!=null)
	    	            {
	    	            	//show or hide label
	    	            	selection.switchLabel();
	    	            	redraw();
	    	            	//updateLabel=true;
	    	            }
	    	        }
	    	        
	    	     }
	    	      
	    	      public void mousePressed(){
	    	    	    edgeSelected();
	    	    	    if (selection2!=null){
	    	    	      selection2.switchLabel();
	    	    	      redraw();
	    	    	    }
	    	    	  }
	    	    	  void edgeSelected(){
	    	    	    for (int j=0;j<edgeCount; j++){
	    	    	       PEdge e=edges[j];
	    	    	       float ydist=e.from.y-e.to.y;
	    	    	       float xdist=e.from.x-e.to.x;
	    	    	       float slope=ydist/xdist;
	    	    	       float intercept=e.from.y-slope*e.from.x;
	    	    	       float y1, y2, x1, x2;
	    	    	       if (ydist>0){
	    	    	          y2=e.from.y;
	    	    	          y1=e.to.y;
	    	    	         } else {
	    	    	            y2=e.to.y;
	    	    	            y1=e.from.y;
	    	    	           }
	    	    	       if(xdist>0){
	    	    	          x2=e.from.x;
	    	    	          x1=e.to.x;
	    	    	         } else {
	    	    	            x2=e.to.x;
	    	    	            x1=e.from.x;
	    	    	           }
	    	    	          
	    	    	       if (abs(slope*mouseX+intercept-mouseY)<10&&mouseX>x1+5&&mouseX<x2-5&&mouseY>y1+5&&mouseY<y2-5){
	    	    	        if (mouseButton==RIGHT)
	    	    	           selection2=e;
	    	    	        }
	    	    	      }//for end
	    	    	  }
	    	    	  void nodeSelected(){
	    	    	    for (int i=0; i<nodeCount; i++){
	    	    	      if(nodes[i].disable==false){
	    	    	        PNode n=nodes[i];
	    	    	        float d=dist(mouseX,mouseY, n.x, n.y );
	    	    	        if (d<5){
	    	    	          selection=n;  
	    	    	        }
	    	    	      }
	    	    	    }
	    	    	  }
	    	    	  
	    	    	  public void mouseDragged(){
	    	    	    nodeSelected();
	    	    	    if(selection!=null &&mousePressed){
	    	    	      if ((mouseX>0&&mouseX<border )&& (mouseY>0&&mouseY<h)){
	    	    	      selection.x=mouseX;
	    	    	      selection.y=mouseY;
	    	    	      }
	    	    	    redraw();
	    	    	    }
	    	    	  }
	    	    	  
	    	    	  
	    	    	 public void mouseReleased(){
	    	    	    selection=null;
	    	    	    selection2=null;
	    	    	    noLoop();
	    	    	 }
	    	    	  
	    	    	 //-----------------------------reset node count---------------------------------------
	    	    	   void resetNode(){
	    	    	     for (int i=0; i<nodeCount; i++){
	    	    	      nodes[i].resetCount();
	    	    	      nodes[i].enable();
	    	    	   }
	    	    	   }
	    	    	   void resetEdge(){
	    	    	     for (int i=0; i<edgeCount; i++){
	    	    	      edges[i].enable();
	    	    	    }
	    	    	   }
	    	    	   
	    	    	   void updateNode(){
	    	    	     for (int i=0; i<nodeCount; i++){
	    	    	      if (nodes[i].oriCount<nodeFilter || nodes[i].count<=0) nodes[i].disable();
	    	    	     }
	    	    	   }
	    	    	   void updateEdge(){
	    	    	     for (int i=0; i<edgeCount; i++){
	    	    	       if (edges[i].count>=edgeFilter){
	    	    	         if(edges[i].from.disable==true || edges[i].to.disable==true) edges[i].disable();
	    	    	       }else {
	    	    	         edges[i].from.decrease(1); //from.count decrease
	    	    	         edges[i].to.decrease(1);
	    	    	         edges[i].disable();
	    	    	       }
	    	    	     }
	    	    	   }
	    	    	     

}
